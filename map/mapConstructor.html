<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Map Editor</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; }
    body { position: relative; height: 100vh; }
    canvas { display: block; background-color: #111; position: absolute; top: 0; left: 0; z-index: 0; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(30,30,30,0.9);
      padding: 10px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <canvas id="editor"></canvas>
  <div id="controls">
    <button id="saveBtn">Save Wall Data</button><br>
  </div>
  <script type="module">
    import { fetchWallData, saveWallData } from './mapConstructor.js';

    let wallData = await fetchWallData(); // Load from server

    const canvas = document.getElementById("editor");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let scale = 1;
    let offsetX = canvas.width / 2;
    let offsetY = canvas.height / 2;
    let draggingCanvas = false;
    let dragStart = null;
    let draggingPoint = null;
    const gridSize = 40;

    let points = [];
    let walls = [];
    let selectedPoint = null;

    let undoStack = [];

    // --- Import map from mapConstructor.js ---
    const pointMap = {};
    let idx = 0;
    const SHIFT_X = -10 * gridSize;
    const SHIFT_Y = -8 * gridSize;

    // Store points as-is (no shift)
    wallData.flat().forEach(([x, y]) => {
      const key = `${x},${y}`;
      if (!(key in pointMap)) {
        pointMap[key] = idx++;
        points.push([x, y]);
      }
    });
    walls = wallData.map(seg => [
      pointMap[`${seg[0][0]},${seg[0][1]}`],
      pointMap[`${seg[1][0]},${seg[1][1]}`]
    ]);

    function drawGrid() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      // Get visible world bounds
      const left = screenToWorld(0, 0)[0];
      const top = screenToWorld(0, 0)[1];
      const right = screenToWorld(canvas.width, 0)[0];
      const bottom = screenToWorld(0, canvas.height)[1];

      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;

      // Vertical grid lines
      let startX = Math.floor(left / gridSize) * gridSize;
      let endX = Math.ceil(right / gridSize) * gridSize;
      for (let x = startX; x <= endX; x += gridSize) {
        const [sx1, sy1] = worldToScreen(x, top);
        const [sx2, sy2] = worldToScreen(x, bottom);
        ctx.beginPath();
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
        ctx.stroke();
      }

      // Horizontal grid lines
      let startY = Math.floor(top / gridSize) * gridSize;
      let endY = Math.ceil(bottom / gridSize) * gridSize;
      for (let y = startY; y <= endY; y += gridSize) {
        const [sx1, sy1] = worldToScreen(left, y);
        const [sx2, sy2] = worldToScreen(right, y);
        ctx.beginPath();
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawOrigin() {
      const [x, y] = worldToScreen(0, 0);
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Shift all drawing by -10 squares left and 8 squares up
    const DRAW_SHIFT_X = -10 * gridSize;
    const DRAW_SHIFT_Y = -8 * gridSize;

    function worldToScreen(x, y) {
      return [
        x * scale + offsetX,
        y * scale + offsetY
      ];
    }

    function screenToWorld(x, y) {
      return [(x - offsetX) / scale, (y - offsetY) / scale];
    }

    function snap(x, y) {
      return [
        Math.round(x / gridSize) * gridSize,
        Math.round(y / gridSize) * gridSize,
      ];
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawOrigin();

      // Shift for drawing walls/points only
      const SHIFT_X = -10 * gridSize;
      const SHIFT_Y = -8 * gridSize;

      // Draw walls
      ctx.strokeStyle = "#f00";
      ctx.lineWidth = 2;
      for (const [aIdx, bIdx] of walls) {
        const [ax, ay] = worldToScreen(points[aIdx][0], points[aIdx][1]);
        const [bx, by] = worldToScreen(points[bIdx][0], points[bIdx][1]);
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      }

      // Draw points
      for (let i = 0; i < points.length; i++) {
        const [x, y] = worldToScreen(points[i][0], points[i][1]);
        ctx.fillStyle = i === selectedPoint ? "#0f0" : "#fff";
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Call this before any change to points or walls
    function pushUndo() {
      undoStack.push({
        points: JSON.parse(JSON.stringify(points)),
        walls: JSON.parse(JSON.stringify(walls))
      });
      // Optional: Limit stack size
      if (undoStack.length > 100) undoStack.shift();
    }

    // Undo function
    function undo() {
      if (undoStack.length > 0) {
        const last = undoStack.pop();
        points = last.points;
        walls = last.walls;
        draw();
      }
    }

    // Listen for Ctrl+Z or Cmd+Z
    window.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        undo();
      }
    });

    canvas.addEventListener("mousedown", e => {
      if (e.button === 1) {
        draggingCanvas = true;
        dragStart = [e.clientX - offsetX, e.clientY - offsetY];
        return; // Prevent point creation!
      }

      const [wx, wy] = screenToWorld(e.clientX, e.clientY);
      const [sx, sy] = snap(wx, wy);

      if (e.button === 2) {
        // Right click to delete point or wall
        for (let i = 0; i < points.length; i++) {
          const [x, y] = points[i];
          if (Math.hypot(x - wx, y - wy) < 10) {
            walls = walls.filter(([a, b]) => a !== i && b !== i).map(([a, b]) => [a > i ? a - 1 : a, b > i ? b - 1 : b]);
            points.splice(i, 1);
            if (selectedPoint === i) selectedPoint = null;
            draw();
            return;
          }
        }
        draw();
        return;
      }

      // Check for existing point
      for (let i = 0; i < points.length; i++) {
        const [x, y] = points[i];
        if (Math.hypot(x - wx, y - wy) < 10) {
          if (selectedPoint === null) {
            selectedPoint = i;
          } else if (selectedPoint !== i) {
            walls.push([selectedPoint, i]);
            selectedPoint = null;
          } else {
            draggingPoint = i;
          }
          draw();
          return;
        }
      }

      points.push([sx, sy]);
      draw();
    });

    canvas.addEventListener("mousemove", e => {
      if (draggingCanvas && dragStart) {
        offsetX = e.clientX - dragStart[0];
        offsetY = e.clientY - dragStart[1];
        draw();
      }
      if (draggingPoint !== null) {
        let [wx, wy] = screenToWorld(e.clientX, e.clientY);
        points[draggingPoint] = snap(wx, wy);
        draw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      draggingCanvas = false;
      draggingPoint = null;
    });

    canvas.addEventListener("wheel", e => {
      const zoom = e.deltaY < 0 ? 1.1 : 0.9;
      const [mx, my] = [e.clientX, e.clientY];
      const [wx, wy] = screenToWorld(mx, my);
      scale = Math.min(Math.max(scale * zoom, 0.1), 4); // Limit zoom
      const [nx, ny] = worldToScreen(wx, wy);
      offsetX += mx - nx;
      offsetY += my - ny;
      draw();
    });

    canvas.addEventListener("contextmenu", e => e.preventDefault());
    canvas.addEventListener("mousedown", e => {
      if (e.button === 1) {
        draggingCanvas = true;
        dragStart = [e.clientX - offsetX, e.clientY - offsetY];
        return; // Prevent point creation!
      }

      const [wx, wy] = screenToWorld(e.clientX, e.clientY);
      const [sx, sy] = snap(wx, wy);

      if (e.button === 2) {
        // Right click to delete point or wall
        for (let i = 0; i < points.length; i++) {
          const [x, y] = points[i];
          if (Math.hypot(x - wx, y - wy) < 10) {
            walls = walls.filter(([a, b]) => a !== i && b !== i).map(([a, b]) => [a > i ? a - 1 : a, b > i ? b - 1 : b]);
            points.splice(i, 1);
            if (selectedPoint === i) selectedPoint = null;
            draw();
            return;
          }
        }
        draw();
        return;
      }

      // Check for existing point
      for (let i = 0; i < points.length; i++) {
        const [x, y] = points[i];
        if (Math.hypot(x - wx, y - wy) < 10) {
          if (selectedPoint === null) {
            selectedPoint = i;
          } else if (selectedPoint !== i) {
            walls.push([selectedPoint, i]);
            selectedPoint = null;
          } else {
            draggingPoint = i;
          }
          draw();
          return;
        }
      }

      points.push([sx, sy]);
      draw();
    });

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    });

    function getWallDataArray() {
      return walls.map(([aIdx, bIdx]) => [
        points[aIdx],
        points[bIdx]
      ]);
    }

    document.getElementById('saveBtn').onclick = async function() {
      const wallData = getWallDataArray();
      await saveWallData(wallData);
      alert('Map saved!');
    };

    draw();
  </script>
</body>
</html>
